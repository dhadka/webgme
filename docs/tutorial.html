<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Learn to use WebGME</title>

</head>
<body>
<h1>Lesson <span style="font-style: italic;">one</span>
- creating our first project</h1>
<div style="text-align: justify;">In
this tutorial you will learn the basic features of WebGME. How to
create projects, how to instentiate objects, how to define your own
language and finally how to build a model according your language.
Along the way you will also learn how to use the different features of
our user-interface like the META&nbsp;and Composition modes.<br>
</div>
<h2>Main parts of the user-interface</h2>
<div style="text-align: justify;">Before
we begin it would be wise to define the different parts of the
user-interface so it would be easier to understand the tutorial later.
So let's see a snapshot with the main areas of the interface:<br>
</div>
<div style="text-align: center;"><img style="width: 600px; height: 543px;" alt="" title="Important areas of the WebGME user-interface" src="./img/ui_parts_base.png"><br>
</div>
<div style="text-align: justify;">So now we know how the
different parts of the UI is called so let's begin with the real
modeling!<br>
</div>
<h2>Creating an empty project</h2>
<div style="text-align: justify;">The
first step on the long path of modeling is to create an empty project.
To do this you simply have to open the project dialog which can be done
by pushing the <img style="width: 30px; height: 22px;" alt="" src="img/glyphicons_144_folder_open.png">
button on the main toolbar. On the dialog simply push the 'Create
empty...' button which gives you a textbox where you can type the
desired name of your project (SignalFlow for example), then you can
start the actual project creation by pressing the 'Create' button. In
your new project you already have a so called basic seed, which is
really the first building blocks which are essential for a project. You
get a 'ROOT' object which will be the root of your conainment hierarchy
and you will put all of your object under it. You also get an 'FCO'
object (stands for First Class Object) which is the root of the
inheritance hierarchy, which means that it will be the base of all your
objects.<br>
</div>
<br>
<h2>Creating the 'Language' folder</h2>
<div style="text-align: justify;">As in WebGME
there is no distinction between your META objects and the actual model
objects you probably would like to separate the building blocks of your
language from the actual models you build with them. To be able to do
this you need a 'place' (a well defined object) where you will be able
to create the elements of your language. In the mode selector choose
the Composition and on the Object Browser select the Root object (the
single FCO object become visible on the main panel). Drag the FCO
object from the Parts panel onto the main panel. Now you've just
created an instance of your FCO! Select it and rename in the property
editor to 'Language'. Now we have our object, but it doesn't have any
rules which means it cannot contain any other object (as that is the
default behaviour). To add a containment rule to our new object we have
to first switch to the META mode (just click on the META label on the
mode selection panel). In this mode the FCO is visible, but you can see
that it is rendered differently (more like an UML class on a UML class
diagram). This mode allows the manipulation of your language rules. To
allow the Language object to have rules first you have to drag it onto
the main panel from the object browser. After dragging the inheritance
relation between Language and FCO becomes visible immediately. To be
able to use the Language as a folder we will allow it to have any kind
of children. To do this we will allow it to have FCO type children.
Select the -diamond headed line - on the line bar and draw a line from
the FCO to the Language object (your valid connection points become
visible once your mouse is over an object, and when you start drawing
your line all the possible endings of the line becomes visible). If we
are done, we can start creating our own language objects. The current
META mode shows the following picture:<br>
</div>
<div style="text-align: center;"><img style="width: 600px; height: 544px;" alt="" src="img/meta_language.png"><br>
<div style="text-align: justify;">
<h2>Elements of the Signal Flow language</h2>
When
we talk about signal flow we usually mean some kind of processing units
which have some signals transmission from one another and usually they
manipulate those signals. This means that for our language we will need
a 'Processing' object, a 'Flow' object which represents the connection
between the processing units and some kind of 'Port' which shows the
source and the destination of flows as a processing unit can receive
signals from different sources and can provide signals towards
different targets. To achieve this we will create the three objects the
same way we created our Language folder. First we select the
Composition mode, than we navigate to our Language folder on the object
browser. We see a totally blank main panel as currently the Language
folder does not have any children. In the parts panel we see the usual
FCO and a grayed Language object because although the Language object
is part of our language now and it is derivate of FCO it cannot be a
children of itself. But we can simply drag and drop the FCO three times
onto the main panel and rename the three new object according our
language. Now we again have our building blocks, but they also need
rules and we must define the relation among them as well.<br>
<div style="text-align: center;"><img style="width: 600px; height: 574px;" alt="" src="img/sf_tut1_31.png"><br>
<div style="text-align: justify;">To
define the rules we need to switch to our META mode. First to separate
the different parts of our language definitions we create a new tab for
our new rules as the existing ones are more generic and not really part
of the Signal Flow language. To create a new tab in the META mode you
have to push the <img style="width: 20px; height: 20px;" alt="" src="img/glyphicons_432_plus.png">
button on the main panel's toolbar, then rename the 'New sheet' to your
liking (to rename a sheet at any time you just simply have to double
click on its name and an in-place editor will start). Now you can use
the known method of dragging your objects from the object browser. You
can notice that unlike the first time when we created the Language
object there is no automatic inheritance relation on the sheet which is
correct as these three object doesn't have inheritance relation among
them (although they are siblings from inheritance point of view). As we
already know how to create containment relation, we will start with
that. Define the rule that a Processing unit can have Ports. Just as a
remainder, you do this by selecting the containment relation and
drawing a line from the contained object to the container.<br>
Now we
have to define that our Flow object can connect two Ports. In WebGME
this means that the Flow object can have a pointer to a source Port and
a destination Port. To define a pointer relation you simply choose the
pointer relation type and draw a line from the owner of the relation to
the target of the relation (so in our case from the Flow to the Port).
Once you done with the drawing a pop-up dialog appears where you can
give name to the pointer relation. There is two predefined name for
pointers, 'src' and 'dst'. They represent the source and destination
pointers necessary for connection creation. Although you could create
pointers with any name, our default visualizations look for these two
when it comes to distinguishing between normal objects and connection
objects. So after creating the two pointer relations our language looks
like this:<br>
<div style="text-align: center;"><img style="width: 600px; height: 575px;" alt="" src="img/sf_tut_32.png"> <br>
<div style="text-align: justify;">Now
we are done with the first version of our language and we are now able
to create a model with these building blocks. Of course it can be seen
that our language is rough-and-ready as we do not even have a container
object which would represent our model object (so we have to define our
processing units directly under the ROOT object) and we know that it
would be good if we would be able to have different kind of processing
units, like the ones that do the actual yet simple signal manipulating
tasks and the more complex ones which can have many simple processing
unit as a part and can implement difficult functionalities. So in the
next tutorial we will do some fine-graining on our language and we will
define some attributes as well.<br>
If you lost somewhere but feel that you learned all there is in this
lesson and you want to continue you should probably need the result of
this lesson which can be downloaded from <a href="tutres/lessonOne.json" download="">here</a>.
If you do not
knwo how to create a project from a file, the lesson ona-and-a-half is
for you!<br>
<h1>Lesson <span style="font-style: italic;">one-and-a-half</span>
- create project from file</h1>
As in the later lessons you have the possibility to start your work
from our results it would be wise to learn how to create a project from
an exported project file. It is very similar to empty project creation
so first you click on the <img style="width: 30px; height: 22px;" alt="" src="img/glyphicons_144_folder_open.png">
button and in the project dialog you press the 'Create from file...'
button. Then you type your project's name and press the 'Import
file...' button. Here another dialog shows where you can use a simple
file selecting dialog by clicking the 'Choose file' button or you can
simply drag and drop your file onto the area below the button. If your
file doesn't have the proper format then this dialog will tell you,
otherwise you can simply create your project by pressing the
'Import..." button.<br>
So now let's head back to our modeling studies!
<h1>Lesson <span style="font-style: italic;">two</span>
- refining our language</h1>
In this tutorial we will show how to fine-grain our riugh-and-ready
language by defining attributes, subclasses. We also show how to create
abstract objects. <br>
As we already mentined in the end of our previous lesson it would be
wise if we could differentiate our processing units for the ones which
do 'simple' tasks and the ones that compose the simple ones to achieve
a more complex manipulation on the signals. In our language we call the
simple processing unit a 'Primitive' and the other a 'Compound' which
prety much covers that it is built by Primitives to represent a more
complex function. As both of the new elements represent the processing
we have to inherit them from our existing Processing object. Now we
will instantiate the new objects in a different way (not by dragging
from the parts panel). First we switch again to Composition mode and
select our Language folder. Then we drag the Processing object from the
object browser onto the main panel. When we drop the object a context
menu appears on the screen asking what operation we would like to do
with the object (for example: copy, move or instantiate). Let's choose
the&nbsp;<img style="width: 24px; height: 18px;" alt="" src="img/glyphicons_222_share.png"> line and create an
instance under the Language folder and rename it to 'Primitive'. When
you are done you can repeat the same method to create the 'Compund'
object.<br>
Now we have to extend our language to have its new rules according the
new objects. So let's change back to META mode and drop the two new
element onto the 'Signal Flow' sheet. Notice that the inheritance
relation among Processing and the new objects becomes visible right
away. As the Compound represents a unit which can contain other
processing units (and Flows among them) we have to insert these two new
containment relations. So once again draw a containment line from
Processing to Compound and one from Flow to Compound. And we are done!
notice that although Primitives can have ports and Compounds can have
ports we do not have to explicitly define these relations as they are
inherited from Processing! So our language looks something like this at
the moment:<br>
<div style="text-align: center;"><img style="width: 600px; height: 288px;" alt="" src="img/sf_tut21.png"><br>
<div style="text-align: justify;">Now as we said the
Primitives are the simple units which do a well defined task. To
describe this task we should create some property of our Primitive
objects. It would be not just a simple property but an attribute of the
type. To create an attribute you simply have to click on the '+' sign
before the 'ATTRIBUTES' label in the area of the given object which
will bring up an in-place text editor where you can give the name of
your new attribute (in our example we call it 'Function'). When your
are done and press the ENTER&nbsp;the attribute&nbsp;dialog
will pop up:<br>
<div style="text-align: center;"><img style="width: 600px; height: 544px;" alt="" src="img/sf_tut22_base.png"><br>
<div style="text-align: justify;">As you can see you are
able to give the type and the default value of your attribute. If your
attribute is an enumeration you &nbsp;should define its possible
values as well (by checking the box before Enumeration a separate
textbox appears where you should give every possible value in a
separate line). For our example the Function attribute would be a
string and it doesn't have a default value. If your are done with the
attribute editing you can press the 'Save' button. Now you have been
taken back to the META mode and your Primitive object now lists the
attribute Function in its attribute section. If for some reason you
want to edit your existing attribute or delete it, you can do that by
simply double-clicking on the attribute label which will bring up the
attribute dialog where you have the extra 'Delete' button.<br>
In our current language we do not have the possibility to differentiate
the ports whether they receive signals or send them. To allow that, we
have to have some definition for Inputs and Outputs. As in the previous
step the Input and Output objects will also be instances of an already
created object, but they extend the Port definition. &nbsp;So using
either of our already discussed instantiation method let's create two
new instances of Port under the Language folder with names Input and
Output. Now to finish our job here we should add these objects to our
language by dragging them onto the Signal Flow sheet under META mode.
Of course because of the inheritance there is not much rule we should
add as the processing units can already have Input and Output because
of their common ancestor. What we on the other hand wan't to avoid is
that we do not want anyone to create just Ports anymore. To achieve
this goal we have to make the Port a so called 'Abstract Class'. To do
this we can select the Port object and then in the property window set
the 'isAbstract' value to 'YES'. When we do this the name of the object
becomes gray which tells us that the object is abstract. Once again
because of the inheritance the Input and Output also became abstract so
let's select them and switch of their isabstract value. You can also
notice that once you have an abstract object it would never appear on
the Parts panel as it cannot be instantiated. <br>
Speaking of abstracts it would be wise to have the Processing also as
abstract as now the definitions of Primitive and Compound are usable on
the other hand we cannot really say the same from the Processing
(because it pretty much covers the same funcionality as the Primitive,
but it lacks the attibute Function). So let's do the previous
isAbstract setting with the Processing as well (and with the Primitive
and Compound!).<br>
To create our first model we go into Composition mode and open the
ROOT. Here we create an instance of a compound as any signal flow model
can be represented as a big Compound. Let's rename to 'First Example'.
If we now navigate into this new object by double-clicking on its main
area you can see that our Parts panel have only the Primitive,
Compound, Input and Output as possible building blocks inside a
Compound. On the other hand we cannot see Flow because we create
connections by actually connecting items (as in case of relations in
the META mode). So if we put an Input and an Output under the First
Example we will be able to connect them. Do not forget that the
direction of drawing is important as we always draw from the source to
the destination. Now let's create one Primitive under the First Example
and let's create one Input and Output to it. We can create those prots
by navigating into the Primitive and instantiate the Input and Output
there. Now we want to connect the already created Input of our First
Example to the Input of the new Primitive. Let's navigate to the First
Example. We would expect that we are able to draw a line between the
Input and the Input of the Primitive, but that is not the case. What is
missing is that now the Ports of the Primitive cannot be seen. To make
them really visible as ports of their parent we have to set their
isPort property to true. To allow all port to behave like this we
should do this change on the Port object under our Language folder as
then the inhertiance will take care of the rest. So let's navigate to
our Language folder, select the Port object and in the
&nbsp;property editor switch the isPort to 'YES'. Now if we
navigate back to First Example we should see the Input and Output of
&nbsp;the Primitive:<br>
<div style="text-align: center;"><img style="width: 600px; height: 542px;" alt="" src="img/sf_tut_23_base.png"><br>
<div style="text-align: justify;">Now we will be able to
connect the Input to the Input of the Primitive and its Output to the
Output of the First Example. Before we would do this let's create a
copy of our primitive! To copy an object you can simply use the drag
and drop method from the Object Browser and select the <img style="width: 20px; height: 20px;" alt="" src="img/glyphicons_432_plus.png"> line in the context menu.
But for now we would like to use a different approach which is the
following: you can copy an object if you push the CTRL
button&nbsp;down and drag the object. While you drag the
same&nbsp;<img style="width: 20px; height: 20px;" alt="" src="img/glyphicons_432_plus.png"> icon and the 'Copy...'
label appears in the ghost box to make you sure that you will create a
copy of your original object. Once we copied the object we copy also
its children so now we will have two Primitives with Input and Ouput
ports. To make our first example complete let's connect the Input of
&nbsp;First Example to the Input of a Primitive then connect its
Output to the Input of the other Primitive, finally connect that
Primitive's Output to the Output of the First Example.Let's also delete
the Flow between the First Example's Input and Output. To do this just
simply select the Flow line, and in its selection box's upper right
corner press the <img style="width: 26px; height: 26px;" alt="" src="img/glyphicons_192_circle_remove.png">
icon. So now we have our very first model in our Signal Flow language:<br>
<div style="text-align: center;"><img style="width: 600px; height: 542px;" alt="" src="img/sf_tut_24_base.png"><br>
<div style="text-align: justify;">Although we can see that
our model is functionally somehow correct we cannot say that it is
visually appealing. So in our next lesson we will address that problem
and try to enhance our model and language definitions to allow visually
appealing model creation! Again if you are lost somewhere our think you
already familiar with things so far you can get our&nbsp;<a href="tutres/lessonTwo.json" download="">here</a>.</div>
</div>
</div>
</div>
<br>
</div>
</div>
</div>
</div>
</div>
</div>
&nbsp;<br>
<br>
<h1>Lesson <span style="font-style: italic;">three</span>
- changing the visual appereance of your language elements</h1>
In
this tutorial you will learn different ways to change the appereance of
your building bircks which would help to the viewer to differentiate
the different parts of a model more easily. </div>
</div>
</div>
</div>
</body></html>